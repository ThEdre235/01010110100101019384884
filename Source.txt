-- Entity Spawner - Script Principal com Shake Screen (ATUALIZADO)
-- Este script deve ser hospedado e chamado via loadstring

return function(Entity)
	--=== Vari√°veis e servi√ßos ===--
	local Players = game:GetService("Players")
	local TweenService = game:GetService("TweenService")
	local Workspace = game:GetService("Workspace")
	local RunService = game:GetService("RunService")
	local ReplicatedStorage = game:GetService("ReplicatedStorage")

	--=== SISTEMA DE SHAKE SCREEN ATUALIZADO ===--
	local player = Players.LocalPlayer
	local playerGui = player:WaitForChild("PlayerGui")
	local camShaker = nil

	-- Inicializa o sistema de shake
	local function initializeShakeSystem()
		local success, result = pcall(function()
			return require(playerGui:WaitForChild("MainUI")
				:WaitForChild("Initiator")
				:WaitForChild("Main_Game")).camShaker
		end)
		
		if success and result then
			camShaker = result
			print("‚úÖ Sistema de shake inicializado com sucesso!")
			return true
		else
			warn("‚ùå Erro ao carregar sistema de shake da c√¢mera: " .. tostring(result))
			return false
		end
	end

	-- Fun√ß√£o que calcula a intensidade do shake baseada na dist√¢ncia
	local function calculateShakeIntensity(distance, settings)
		-- Se est√° fora do range, n√£o faz shake
		if distance > settings.Range then
			return 0
		end
		
		-- Se est√° muito perto, usa magnitude m√°xima
		if distance <= settings.MinDistance then
			return settings.MaxMagnitude
		end
		
		-- Calcula a intensidade baseada na dist√¢ncia (interpola√ß√£o linear)
		local normalizedDistance = (distance - settings.MinDistance) / (settings.Range - settings.MinDistance)
		local intensity = settings.MaxMagnitude - (normalizedDistance * (settings.MaxMagnitude - settings.MinMagnitude))
		
		return math.max(0, intensity)
	end

	-- Fun√ß√£o que aplica shake baseado na dist√¢ncia (shake √∫nico)
	local function triggerDistanceShake(distance, customSettings)
		if not camShaker then return end
		
		local settings = customSettings or Entity.ShakeSettings
		if not settings.Enabled then return end
		
		local intensity = calculateShakeIntensity(distance, settings)
		
		-- S√≥ aplica shake se a intensidade for significativa
		if intensity > 0.1 then
			camShaker:ShakeOnce(
				intensity,
				settings.Roughness,
				settings.FadeIn,
				settings.FadeOut
			)
		end
	end

	-- Fun√ß√£o para shake cont√≠nuo (novo sistema)
	local activeShakeConnections = {}
	local currentShakeIntensity = 0
	
	local function triggerContinuousShake(distance, settings)
		if not camShaker or not settings.Enabled then return end
		
		local intensity = calculateShakeIntensity(distance, settings)
		
		-- Se a intensidade mudou significativamente, aplica novo shake
		if math.abs(intensity - currentShakeIntensity) > 0.2 or intensity == 0 then
			currentShakeIntensity = intensity
			
			if intensity > 0.1 then
				-- Aplica shake cont√≠nuo
				camShaker:ShakeOnce(
					intensity * 0.7, -- Reduz um pouco para n√£o ser muito intenso
					settings.Roughness,
					settings.FadeIn,
					settings.FadeOut * 1.5 -- Fade out mais longo para continuidade
				)
			end
		end
	end

	-- Sistema de monitoramento de shake baseado em range
	local function startShakeSystem(entityModel, movePart, shakeSettings)
		if not shakeSettings or not shakeSettings.Enabled then
			print("üîá Sistema de shake desabilitado")
			return
		end
		
		-- Inicializa o sistema de shake se necess√°rio
		if not camShaker then
			if not initializeShakeSystem() then
				warn("‚ùå Sistema de shake n√£o p√¥de ser inicializado.")
				return
			end
		end
		
		print("üéÆ Iniciando sistema de shake com range de " .. shakeSettings.Range .. " studs")
		
		local lastShakeTime = 0
		local settings = shakeSettings
		local lastDistance = math.huge
		
		local shakeConn
		shakeConn = RunService.Heartbeat:Connect(function()
			-- S√≥ faz shake se configurado para funcionar quando parado OU quando a entidade est√° se movendo
			if settings.OnlyWhenMoving and not EntityState.isMoving then
				return
			end
			
			local currentTime = tick()
			
			-- Controla a frequ√™ncia do shake
			if currentTime - lastShakeTime < settings.UpdateInterval then
				return
			end
			
			-- Calcula dist√¢ncia at√© o jogador
			local character = player.Character
			local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
			
			if humanoidRootPart then
				local distance = (movePart.Position - humanoidRootPart.Position).Magnitude
				
				-- Debug da dist√¢ncia (pode remover depois)
				if math.abs(distance - lastDistance) > 5 then
					print("üìè Dist√¢ncia da entidade: " .. math.floor(distance) .. " studs")
					lastDistance = distance
				end
				
				-- Aplica shake baseado na dist√¢ncia
				if settings.ContinuousShake then
					triggerContinuousShake(distance, settings)
				else
					-- S√≥ faz shake se a dist√¢ncia mudou significativamente
					if math.abs(distance - lastDistance) > 2 then
						triggerDistanceShake(distance, settings)
						lastDistance = distance
					end
				end
				
				lastShakeTime = currentTime
			end
		end)
		
		-- Armazena a conex√£o para limpeza
		activeShakeConnections[entityModel] = shakeConn
		
		-- Limpa a conex√£o quando a entidade for destru√≠da
		entityModel.Destroying:Connect(function()
			print("üßπ Limpando sistema de shake da entidade")
			if activeShakeConnections[entityModel] then
				activeShakeConnections[entityModel]:Disconnect()
				activeShakeConnections[entityModel] = nil
			end
			currentShakeIntensity = 0
		end)
	end

	-- Fun√ß√£o para parar manualmente o shake (√∫til para debug)
	local function stopAllShakes()
		for entityModel, connection in pairs(activeShakeConnections) do
			if connection then
				connection:Disconnect()
			end
		end
		activeShakeConnections = {}
		currentShakeIntensity = 0
		print("üõë Todos os shakes foram parados")
	end

	-- Fun√ß√£o de teste do sistema de shake (para debug)
	local function testShakeSystem(intensity, roughness, fadeIn, fadeOut)
		if not camShaker then
			if not initializeShakeSystem() then
				warn("‚ùå N√£o foi poss√≠vel testar - sistema de shake n√£o inicializado")
				return
			end
		end
		
		intensity = intensity or 3
		roughness = roughness or 15
		fadeIn = fadeIn or 0.1
		fadeOut = fadeOut or 0.5
		
		print("üß™ Testando shake - Intensidade: " .. intensity)
		camShaker:ShakeOnce(intensity, roughness, fadeIn, fadeOut)
	end

	--=== CONTROLE DE ESTADO DA ENTIDADE ===--
	local EntityState = {
		isMoving = false,
		canKill = true,
		canBreakLights = true
	}

	--=== FUN√á√ïES UTILIT√ÅRIAS ===--
	local function withHeightOffset(cf, offset)
		return cf + Vector3.new(0, offset, 0)
	end

	local function getTweenTime(startCFrame, endCFrame, speed)
		local distance = (startCFrame.Position - endCFrame.Position).Magnitude
		return distance / speed
	end

	-- Retorna as salas existentes ordenadas
	local function getValidRoomNumbers()
		local currentRooms = Workspace.CurrentRooms:GetChildren()
		local roomNumbers = {}
		for _, room in ipairs(currentRooms) do
			local roomNum = tonumber(room.Name)
			if roomNum then
				table.insert(roomNumbers, roomNum)
			end
		end
		table.sort(roomNumbers)
		return roomNumbers
	end

	local function getMovePart(model)
		if model:FindFirstChild("RushNew") then
			return model.RushNew
		elseif model.PrimaryPart then
			return model.PrimaryPart
		else
			for _, v in ipairs(model:GetDescendants()) do
				if v:IsA("BasePart") then
					return v
				end
			end
		end
		return nil
	end

	--=== SISTEMA DE QUEBRA E FLICKER DE LUZES ===--
	local Module_Events = nil
	local function initializeLightSystem()
		local success, result = pcall(function()
			return require(ReplicatedStorage:WaitForChild("ClientModules"):WaitForChild("Module_Events"))
		end)
		
		if success and result then
			Module_Events = result
			return true
		else
			warn("Erro ao carregar Module_Events.")
			return false
		end
	end

	-- (Restante do script permanece igual, incluindo light breaking, kill, spawn, etc...)

	--=== FUN√á√ÉO PRINCIPAL DE SPAWN ===--
	local function spawnEntity(settings)
		local customEntityName = settings.Name or "EntityModel"
		local EntityM = game:GetObjects(settings.Model)[1]
		if not EntityM then
			warn("Entity model not found!")
			return
		end
		EntityM.Name = customEntityName
		EntityM.Parent = Workspace

		local roomNumbers = getValidRoomNumbers()
		if #roomNumbers == 0 then
			warn("Nenhuma sala encontrada!")
			EntityM:Destroy()
			return
		end

		local movePart = getMovePart(EntityM)
		if not movePart then
			warn("Nenhuma parte moviment√°vel encontrada no modelo da entidade!")
			EntityM:Destroy()
			return
		end

		-- Inicializa o sistema de luzes (quebra e flicker)
		initializeLightSystem()

		-- Inicializa o sistema de shake
		initializeShakeSystem()

		-- Flicker inicial em todas as salas (se habilitado)
		if settings.LightFlicker.Enabled and settings.LightFlicker.OnSpawn then
			flickerAllRooms(settings.LightFlicker.Duration)
		end

		-- Inicia o sistema de kill range (se Killable for true e KillRange > 0)
		startKillRange(EntityM, movePart, settings.KillRange, settings.Killable, settings.OnDeath)

		-- Inicia o sistema de quebra de luzes
		startLightBreaking(EntityM, movePart, settings)

		-- Inicia o sistema de flicker durante movimento
		startLightFlicker(EntityM, movePart, settings)

		-- Inicia o sistema de shake screen atualizado
		startShakeSystem(EntityM, movePart, settings.ShakeSettings)

		-- Opcional: Teste inicial do sistema de shake (remova ap√≥s testar)
		-- testShakeSystem()

		-- Executa o callback OnEntitySpawn ap√≥s a entidade ser criada
		if settings.OnEntitySpawn and type(settings.OnEntitySpawn) == "function" then
			pcall(settings.OnEntitySpawn, EntityM, movePart)
		end

		-- (Resto da fun√ß√£o spawnEntity permanece igual...)
		coroutine.wrap(function()
			local isReversed = settings.Reversed
			local rebounding = settings.Rebounding and settings.Rebounding.Enabled
			local minRebounds = (settings.Rebounding and settings.Rebounding.MinTimes) or 1
			local maxRebounds = (settings.Rebounding and settings.Rebounding.MaxTimes) or minRebounds
			local reboundDelay = settings.Rebounding and settings.Rebounding.Delay or 0

			setStartPositionConditional(movePart, roomNumbers, settings, isReversed)
			
			EntityState.isMoving = false
			task.wait(settings.WaitTime)

			if rebounding and maxRebounds > 0 then
				local rebounds = minRebounds
				if maxRebounds > minRebounds then
					rebounds = math.random(minRebounds, maxRebounds)
				end

				for rep = 1, rebounds do
					roomNumbers = getValidRoomNumbers()
					moveEntityThroughRoomsByNodes(movePart, roomNumbers, settings, isReversed)
					if reboundDelay and reboundDelay > 0 then
						EntityState.isMoving = false
						task.wait(reboundDelay)
					end
					if rep == rebounds then
						local goingBack = (rep % 2 == 1) and (not isReversed) or isReversed
						roomNumbers = getValidRoomNumbers()
						animateDespawnAtEdge(movePart, roomNumbers, settings, goingBack, EntityM)
						warn(EntityM.Name .. " DESAPARECEU ANIMANDO PARA BAIXO ap√≥s rebotes ("..tostring(rebounds)..")!")
						return
					end
					roomNumbers = getValidRoomNumbers()
					moveEntityThroughRoomsByNodes(movePart, roomNumbers, settings, not isReversed)
					if rep < rebounds and reboundDelay and reboundDelay > 0 then
						task.wait(reboundDelay)
					end
				end
				local goingBack = (rebounds % 2 == 1) and (not isReversed) or isReversed
				roomNumbers = getValidRoomNumbers()
				animateDespawnAtEdge(movePart, roomNumbers, settings, goingBack, EntityM)
				warn(EntityM.Name .. " terminou todos os rebotes ("..tostring(rebounds)..") e sumiu ANIMANDO PARA BAIXO.")
			else
				roomNumbers = getValidRoomNumbers()
				moveEntityThroughRoomsByNodes(movePart, roomNumbers, settings, isReversed)
				roomNumbers = getValidRoomNumbers()
				animateDespawnAtEdge(movePart, roomNumbers, settings, isReversed, EntityM)
				warn(EntityM.Name .. " terminou o movimento e sumiu ANIMANDO PARA BAIXO.")
			end
		end)()
	end

	-- Executa o spawn da entidade
	spawnEntity(Entity)
end