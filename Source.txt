-- Entity Spawner - Script Principal com Shake Screen ATUALIZADO
-- Este script deve ser hospedado e chamado via loadstring

return function(Entity)
	--=== Vari√°veis e servi√ßos ===--
	local Players = game:GetService("Players")
	local TweenService = game:GetService("TweenService")
	local Workspace = game:GetService("Workspace")
	local RunService = game:GetService("RunService")
	local ReplicatedStorage = game:GetService("ReplicatedStorage")

	--=== SISTEMA DE SHAKE SCREEN ATUALIZADO ===--
	local player = Players.LocalPlayer
	local playerGui = player:WaitForChild("PlayerGui")
	local camShaker = nil

	-- Inicializa o sistema de shake
	local function initializeShakeSystem()
		local success, result = pcall(function()
			return require(playerGui:WaitForChild("MainUI")
				:WaitForChild("Initiator")
				:WaitForChild("Main_Game")).camShaker
		end)
		
		if success and result then
			camShaker = result
			print("‚úÖ Sistema de shake inicializado com sucesso!")
			return true
		else
			warn("‚ùå Erro ao carregar sistema de shake da c√¢mera: " .. tostring(result))
			return false
		end
	end

	-- Fun√ß√£o que calcula a intensidade do shake baseada na dist√¢ncia
	local function calculateShakeIntensity(distance, settings)
		local range = settings.Range or settings.MaxDistance or 80
		local minDist = settings.MinDistance or 5
		local maxMag = settings.MaxMagnitude or 4
		local minMag = settings.MinMagnitude or 0.5

		if distance > range then
			return 0
		end
		if distance <= minDist then
			return maxMag
		end
		local normalizedDistance = (distance - minDist) / (range - minDist)
		local intensity = maxMag - (normalizedDistance * (maxMag - minMag))
		return math.max(0, intensity)
	end

	-- Fun√ß√£o que aplica shake baseado na dist√¢ncia (shake √∫nico)
	local function triggerDistanceShake(distance, customSettings)
		if not camShaker then return end
		
		local settings = customSettings or Entity.ShakeSettings
		if not settings.Enabled then return end
		
		local intensity = calculateShakeIntensity(distance, settings)
		
		-- S√≥ aplica shake se a intensidade for significativa
		if intensity > 0.1 then
			camShaker:ShakeOnce(
				intensity,
				settings.Roughness or 15,
				settings.FadeIn or 0.1,
				settings.FadeOut or 0.8
			)
		end
	end

	-- Fun√ß√£o para shake cont√≠nuo (novo sistema)
	local activeShakeConnections = {}
	local currentShakeIntensity = 0
	
	local function triggerContinuousShake(distance, settings)
		if not camShaker or not settings.Enabled then return end
		
		local intensity = calculateShakeIntensity(distance, settings)
		
		-- Se a intensidade mudou significativamente, aplica novo shake
		if math.abs(intensity - currentShakeIntensity) > 0.2 or intensity == 0 then
			currentShakeIntensity = intensity
			
			if intensity > 0.1 then
				camShaker:ShakeOnce(
					intensity * 0.7,
					settings.Roughness or 15,
					settings.FadeIn or 0.1,
					(settings.FadeOut or 0.8) * 1.5
				)
			end
		end
	end

	-- Sistema de monitoramento de shake baseado em range
	local function startShakeSystem(entityModel, movePart, shakeSettings)
		if not shakeSettings or not shakeSettings.Enabled then
			print("üîá Sistema de shake desabilitado")
			return
		end
		
		if not camShaker then
			if not initializeShakeSystem() then
				warn("‚ùå Sistema de shake n√£o p√¥de ser inicializado.")
				return
			end
		end

		print("üéÆ Iniciando sistema de shake com range de " .. (shakeSettings.Range or shakeSettings.MaxDistance or 80) .. " studs")
		
		local lastShakeTime = 0
		local settings = shakeSettings
		local lastDistance = math.huge
		
		local shakeConn
		shakeConn = RunService.Heartbeat:Connect(function()
			-- S√≥ faz shake se configurado para funcionar quando parado OU quando a entidade est√° se movendo
			if settings.OnlyWhenMoving and not EntityState.isMoving then
				return
			end
			
			local currentTime = tick()
			if currentTime - lastShakeTime < (settings.UpdateInterval or 0.1) then
				return
			end

			local character = player.Character
			local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
			
			if humanoidRootPart then
				local distance = (movePart.Position - humanoidRootPart.Position).Magnitude
				
				if math.abs(distance - lastDistance) > 5 then
					print("üìè Dist√¢ncia da entidade: " .. math.floor(distance) .. " studs")
					lastDistance = distance
				end
				
				if settings.ContinuousShake then
					triggerContinuousShake(distance, settings)
				else
					if math.abs(distance - lastDistance) > 2 then
						triggerDistanceShake(distance, settings)
						lastDistance = distance
					end
				end
				
				lastShakeTime = currentTime
			end
		end)
		
		activeShakeConnections[entityModel] = shakeConn
		entityModel.Destroying:Connect(function()
			print("üßπ Limpando sistema de shake da entidade")
			if activeShakeConnections[entityModel] then
				activeShakeConnections[entityModel]:Disconnect()
				activeShakeConnections[entityModel] = nil
			end
			currentShakeIntensity = 0
		end)
	end

	-- O RESTANTE DO SEU SCRIPT ORIGINAL SEGUE ABAIXO (INCLUINDO EntityState, sistemas de luz, movimento, etc)
	-- ... (sem altera√ß√µes)

	--=== CONTROLE DE ESTADO DA ENTIDADE ===--
	local EntityState = {
		isMoving = false,
		canKill = true,
		canBreakLights = true
	}

	-- ... (restante do script igual ao seu original, sem alterar nada)

	--=== FUN√á√ÉO PRINCIPAL DE SPAWN ===--
	local function spawnEntity(settings)
		local customEntityName = settings.Name or "EntityModel"
		local EntityM = game:GetObjects(settings.Model)[1]
		if not EntityM then
			warn("Entity model not found!")
			return
		end
		EntityM.Name = customEntityName
		EntityM.Parent = Workspace

		local roomNumbers = getValidRoomNumbers()
		if #roomNumbers == 0 then
			warn("Nenhuma sala encontrada!")
			EntityM:Destroy()
			return
		end

		local movePart = getMovePart(EntityM)
		if not movePart then
			warn("Nenhuma parte moviment√°vel encontrada no modelo da entidade!")
			EntityM:Destroy()
			return
		end

		-- Inicializa o sistema de luzes (quebra e flicker)
		initializeLightSystem()

		-- Inicializa o sistema de shake
		initializeShakeSystem()

		-- Flicker inicial em todas as salas (se habilitado)
		if settings.LightFlicker.Enabled and settings.LightFlicker.OnSpawn then
			flickerAllRooms(settings.LightFlicker.Duration)
		end

		-- Inicia o sistema de kill range (se Killable for true e KillRange > 0)
		startKillRange(EntityM, movePart, settings.KillRange, settings.Killable, settings.OnDeath)

		-- Inicia o sistema de quebra de luzes
		startLightBreaking(EntityM, movePart, settings)

		-- Inicia o sistema de flicker durante movimento
		startLightFlicker(EntityM, movePart, settings)

		-- Inicia o sistema de shake screen baseado na dist√¢ncia (ATUALIZADO)
		startShakeSystem(EntityM, movePart, settings.ShakeSettings)

		-- Executa o callback OnEntitySpawn ap√≥s a entidade ser criada
		if settings.OnEntitySpawn and type(settings.OnEntitySpawn) == "function" then
			pcall(settings.OnEntitySpawn, EntityM, movePart)
		end

		-- O restante da l√≥gica permanece igual...
		coroutine.wrap(function()
			-- ... (rebounds, movimento, despawn, etc)
			-- (N√£o altere essa parte, apenas mantenha igual ao original)
		end)()
	end

	-- Executa o spawn da entidade
	spawnEntity(Entity)
end